name: Devopness - Request

on:
    workflow_call:
        inputs:
            host:
                type: string
                required: true
                description: "Host to send the request to"
            path:
                type: string
                required: true
                description: "URL path to send the request to (relative to the host)"
            method:
                type: string
                required: true
                description: "HTTP method to use for the request (GET, POST, etc.)"
            token:
                type: string
                required: true
                description: "Token to use for authentication"
            data:
                type: string
                required: false
                default: ""
                description: "Data to send with the request (JSON format)"

        outputs:
            id:
                value: ${{ jobs.perform-request.outputs.request-id }}
                description: "ID of the action (from X-Devopness-Action-Id header)"
            status:
                value: ${{ jobs.perform-request.outputs.status }}
                description: "Status code of the response"
            response:
                value: ${{ jobs.perform-request.outputs.response }}
                description: "Response from the request"

jobs:
    perform-request:
        runs-on: ubuntu-latest
        outputs:
            request-id: ${{ steps.request.outputs.request-id }}
            status: ${{ steps.request.outputs.status }}
            response: ${{ steps.request.outputs.response }}
        steps:
            - name: Send request
              id: request
              run: |
                  # Mask sensitive values in logs
                  echo "::add-mask::${{ inputs.token }}"

                  # Validate HTTP method
                  if [[ ! "${{ inputs.method }}" =~ ^(GET|POST|PUT|DELETE|PATCH)$ ]]; then
                    echo "::error::Invalid HTTP method: ${{ inputs.method }}. Allowed methods are GET, POST, PUT, DELETE, PATCH."
                    exit 1
                  fi

                  # Construct the full URL
                  URL="https://${{ inputs.host }}${{ inputs.path }}"
                  echo "::debug::Sending ${{ inputs.method }} request to: $URL"

                  # Prepare curl command
                  CMD=(
                    curl -s -o response.json
                    -D headers.txt
                    -w "%{http_code}"
                    -H "Authorization: Bearer ${{ inputs.token }}"
                    -H "Content-Type: application/json"
                    -X "${{ inputs.method }}"
                  )

                  # Add data if provided (skip for GET/DELETE)
                  if [[ -n "${{ inputs.data }}" && ! "${{ inputs.method }}" =~ ^(GET|DELETE)$ ]]; then
                    CMD+=(-d "${{ inputs.data }}")
                  fi

                  CMD+=("$URL")

                  # Execute the request
                  HTTP_STATUS=$("${CMD[@]}")
                  CURL_EXIT=$?

                  # Check for curl errors
                  if [ $CURL_EXIT -ne 0 ]; then
                    echo "::error::Network error - Failed to connect to the server (cURL exit code: $CURL_EXIT)"
                    exit 1
                  fi

                  # Handle HTTP response codes (consider all 2xx as success)
                  if [[ $HTTP_STATUS -lt 200 || $HTTP_STATUS -ge 300 ]]; then
                    echo "::error::Request failed with status code $HTTP_STATUS"
                    jq -c . response.json 2>/dev/null || cat response.json

                    ERROR_RESPONSE=$(cat response.json)
                    echo "::error::Response: $ERROR_RESPONSE"
    
                    exit 1
                  fi

                  # Extract action ID from headers
                  REQUEST_ID=$(grep -i '^X-Devopness-Action-Id:' headers.txt | awk '{print $2}' | tr -d '\r')

                  # Convert to integer or set empty
                  REQUEST_ID=$((REQUEST_ID)) 2>/dev/null || REQUEST_ID=""

                  # Process response body
                  if jq -e . response.json >/dev/null 2>&1; then
                    RESPONSE_BODY=$(jq -c . response.json)
                  else
                    RESPONSE_BODY=$(cat response.json | tr -d '\n')
                  fi

                  # Set outputs
                  {
                    echo "request-id=$REQUEST_ID"
                    echo "status=$HTTP_STATUS" 
                    echo "response=$RESPONSE_BODY"
                  } >> $GITHUB_OUTPUT

                  echo "::debug::Request processed. Status: $HTTP_STATUS, Action ID: ${REQUEST_ID:-none}"

            - name: Cleanup temporary files
              if: always()
              run: |
                  rm -f headers.txt response.json
